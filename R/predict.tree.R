#' @title Prediction Based on Fitted 'tree' Object
#' @description Generates a vector of prediction values for some fitted
#' \code{tree} object.
#' @param object Fitted object of class \code{tree}.
#' @param data Data containing the response variable to be predicted.
#' @param ... Additional arguments.
#' @details Supports classification trees only! Generic \code{predict()}
#' function for class \code{tree}, so that this method will be dispatched if
#' \code{predict(object, ...)} is passed an object of class \code{tree}.
#' Internally uses the recursive function \code{singlePred(object)} to classify
#' single observations by passing the observation down the tree. A final
#' prediction is generated by looping through \code{data}.
#' @return A vector of predictions.
#' @export
#' @examples
#' # Sample split
#' data <- iris
#' set.seed(1337)
#' rows <- sample.int(nrow(data), size = floor(0.7*nrow(data)), replace = FALSE)
#' trainData <- data[rows,]
#' testData <- data[-rows,]
#' # Create fitted 'tree' object
#' fit <- tree(Species ~ .,
#'             data = trainData,
#'             m = 2,
#'             minsplit = 20,
#'             minbucket = 5,
#'             maxdepth = 3)
#' # Make prediction
#' pred <- predict(fit, testData)
predict.tree <- function(object, data, ...) {
  # Recursive tree walk to generate single prediction
  singlePred <- function(object, data) {
    # Stop recursion if leaf is reached
    if(class(object) == "leaf") {
      object$prediction
    } else {
      splitVar <- object$rule$var
      splitVal <- object$rule$val
      # Construct dynamic relation string for numeric/categorial split cases
      if(object$rule$type == "numeric") {
        rel <- paste(data[[splitVar]],
                     "<",
                     splitVal, sep = "")
      } else {
        rel <- paste("\"", data[[splitVar]], "\"",
                     "!=",
                     "\"", splitVal, "\"", sep = "")
      }
      # Turn the character 'rel' into an expression and evaluate it: Return Bool
      isLeft <- eval(parse(text = rel))
      # Recursively iterate through tree until leaf is reached
      if(isLeft) {
        singlePred(object$left, data)
      } else {
        singlePred(object$right, data)
      }
    }
  }

  response <- object$names$response
  # Proceed to root node
  object <- object$root
  # Initialize prediction vector, respect orig. format of response variable
  if(is.factor(data[[response]])) {
    pred <- factor(levels = levels(data[[response]]))
  } else {
    pred <- NULL
  }
  # Get prediction for each observation in test, using object (tree)
  for(row in 1:nrow(data)) {
    pred[row] <- singlePred(object, data[row,])
  }
  # Store observed and predicted response values in data.frame
  pred
}
